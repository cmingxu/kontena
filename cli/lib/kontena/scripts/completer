#!/usr/bin/env ruby
# encoding: UTF-8

require File.expand_path('../../../kontena/main_command', __FILE__)

words = ARGV
words.shift

def recurse_cmd(parent, cmds = [])
  return [parent, []] if cmds.empty?
  word = cmds.shift
  command_class = parent.respond_to?(:recognised_subcommands) ? parent : parent.subcommand_class
  commands = command_class.recognised_subcommands.select{|command| command.names.any?{|name| name.start_with?(word)}}

  if cmds.empty?
    if commands.empty?
      return [parent, nil]
    else
      cmds.unshift(word)
      return [parent, cmds]
    end
  elsif commands.size == 1
    return recurse_cmd(commands.first, cmds)
  else
    return [parent, cmds]
  end
end

if words.size == 0
  puts Kontena::MainCommand.recognised_subcommands.map(&:names)
  exit
else
  cmd, remaining_words = recurse_cmd(Kontena::MainCommand, words.dup)
  if cmd
    command_class = cmd.respond_to?(:recognised_subcommands) ? cmd : cmd.subcommand_class
  end
  unless cmd.nil?
    if command_class.has_subcommands?
      if remaining_words.first
        results = command_class.recognised_subcommands.flat_map(&:names).select{|name| name.start_with?(remaining_words.first)}
      else
        results = command_class.recognised_subcommands.flat_map(&:names)
      end
      if remaining_words.first && results.size == 1 && results.any?{|name| name == remaining_words.first}
        command_class = command_class.recognised_subcommands.find{|sc| sc.names.include?(remaining_words.first)}.subcommand_class
        if remaining_words.size > 1
          word = remaining_words.last
        end
        if command_class.has_subcommands?
          if word.nil?
            puts command_class.recognised_subcommands.flat_map(&:names).join("\n")
          else
            puts command_class.recognised_subcommands.flat_map(&:names).select{|name| name.start_with?(word)}.join("\n")
          end
          exit
        end
      else
        puts results.join("\n")
        exit
      end
    end
  end

  if command_class
    if words.empty?
      if command_class.parameters.empty?
        exit
      elsif command_class.respond_to?(:complete)
        puts command_class.complete
      end
      exit
    end
    if words.last.start_with?('-')
      opts = command_class.recognised_options.flat_map(&:switches).select{|sw| sw.start_with?(words.last)}
      if opts.size == 1 && opts.first == words.last
        opt = command_class.recognised_options.find{|opt| opt.switches.include?(opts.first)}
        if opt.type == :flag
          if command_class.respond_to?(:complete)
            puts command_class.complete
          end
        else
          if command_class.respond_to?(:complete_option)
            puts command_class.complete_option(opt.switches.first)
          end
        end
      else
        puts opts.join("\n")
      end
      exit
    elsif command_class.respond_to?(:complete)
      puts command_class.complete(words.last)
    end
  end
end
